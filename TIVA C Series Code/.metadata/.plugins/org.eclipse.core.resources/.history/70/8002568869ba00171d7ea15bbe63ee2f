/*****************************************************************
 * SecondDraft
 * This file is created to test code for low frequency waves
 * Wave: Square,Sine,Ramp,Triangle Wave
 * Frequency 100Hz
 * DAC 8 bit Therefore values will range from 0-255
 * Zero Value 127
 * Full Scale Value 127
 * No of samples 1000
 * Created: 18/10/2017 3:02 PM
 * Author : Ayush Gaurav
 * B-Tech Final Year
 * ECED
 * MNNIT Allahabad
 ****************************************************************/

/**** macro definitions ******************/

#define DACBit              8
#define ZeroVal             127
#define FullScaleVal        127
#define NumberOfSampleBits  8
#define NumberOfSamples     (1<<NumberOfSampleBits)
#define oneHertzValue       2368


/*** All the required header files********/
#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "driverlib/sysctl.h"
#include "driverlib/gpio.h"
#include "inc/hw_gpio.h"
#include <math.h>
#include "driverlib/adc.h"
#include "lcd.h"
#include "samples.h"
#include "driverlib/uart.h"

#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/debug.h"
#include "driverlib/interrupt.h"
#include "driverlib/gpio.h"
#include "inc/tm4c123gh6pm.h

/************* function declarartions*******/
void portInit();
void calculateSamples();
void peripheralEnable();
void ADC0Enable();
void uartEnable();
void calculateSamplesSquare();
void calculateSamplesSine();
void calculateSamplesTriangle();
void calculateSamplesRamp();

/****** Array for Samples *****************/
volatile unsigned char samples[NumberOfSamples];

/***********Global Declaration*************/
unsigned long int phaseAccumulatorReg;
unsigned long int frequencyReg;
unsigned long int frequencyVariable=0;
int main(void) {
    lcdInit();
    lcdClear();
    lcdGotoxy(1,0);
    lcdString("Wave Rider 1.0");
    _delay_ms(1000);
    calculateSamples();
    portInit();
    peripheralEnable();
    ADC0Enable();
    uartEnable();
    phaseAccumulatorReg=0;
    frequencyReg=oneHertzValue*frequencyVariable;
    while(1){
        GPIOPinWrite(GPIO_PORTB_BASE,0xff,samples[phaseAccumulatorReg>>(32-NumberOfSampleBits)]);
        phaseAccumulatorReg=(phaseAccumulatorReg)+frequencyReg;
    }
}
void portInit(){
    SysCtlClockSet(SYSCTL_SYSDIV_2_5|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, 0xff);
}
void calculateSamples(){
    //calculateSamplesSquare();
    calculateSamplesSine();
    //calculateSamplesTriangle();
    //calculateSamplesRamp();
}

void peripheralEnable(){
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
    ADCHardwareOversampleConfigure(ADC0_BASE, 64);
 }
/****************************************
 * This function is used to enable UART0
 * The baudrate is set at 9600
 ****************************************/
void uartEnable(){
    GPIOPinConfigure(GPIO_PA0_U0RX);//Configure Pin A0 as RX of U0
    GPIOPinConfigure(GPIO_PA1_U0TX);//Configure Pin A1 as TX of U0
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
    UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 9600,
        (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
}
/***********************************************************************
 * This function is used to send a string of character with a delimiter
 ***********************************************************************/
void tranString(char * data,char delimeter){
    int k=0;
    while(data[k]){
        UARTCharPut(UART0_BASE,data[k++]);
    }
    UARTCharPut(UART0_BASE,delimeter);
}
/********************************************************************
 * This function is used to enable UART0 Rx And Rx timeout Interrupt
 *******************************************************************/
void uartInterruptEnable(){
    IntMasterEnable();//Enable processor interrupt
    IntEnable(INT_UART0);//Enable interrupt on UART0
    UARTIntEnable(UART0_BASE, UART_INT_RX | UART_INT_RT);//Enable RX interrupt ant rx Timeout interrupt
}
/****************************************
 * Interrupt sub routine for Uart0
 * Change the name of ISR in startup file
 * Refer to manual for proper instruction
 ****************************************/
void UARTIntHandler(void){
    uint32_t ui32Status;
    ui32Status = UARTIntStatus(UART0_BASE, true); //get interrupt status
    UARTIntClear(UART0_BASE, ui32Status); //clear the asserted interrupts
    while(UARTCharsAvail(UART0_BASE)){ //loop while there are chars
        UARTCharPut(UART0_BASE, UARTCharGet(UART0_BASE));
    }
}
void ADC0Enable(){
    ADCSequenceConfigure(ADC0_BASE, 1, ADC_TRIGGER_PROCESSOR, 0);
    ADCSequenceStepConfigure(ADC0_BASE, 1, 0, ADC_CTL_CH0);
    ADCSequenceStepConfigure(ADC0_BASE, 1, 1, ADC_CTL_CH0);
    ADCSequenceStepConfigure(ADC0_BASE, 1, 2, ADC_CTL_CH0);
    ADCSequenceStepConfigure(ADC0_BASE,1,3,ADC_CTL_CH0|ADC_CTL_IE|ADC_CTL_END);
    ADCSequenceEnable(ADC0_BASE, 1);
    GPIOPinTypeADC(GPIO_PORTD_BASE, GPIO_PIN_0);

}
unsigned int readADC(){
    unsigned int Avg;
        uint32_t ADC0Value[4];
        ADCIntClear(ADC0_BASE, 1);
        ADCProcessorTrigger(ADC0_BASE, 1);
        while(!ADCIntStatus(ADC0_BASE, 1, false));
        ADCSequenceDataGet(ADC0_BASE, 1, ADC0Value);
        Avg = (ADC0Value[0] + ADC0Value[1] + ADC0Value[2] + ADC0Value[3] + 2)/4;
        return(Avg);
}

void calculateSamplesSquare(){
    uint16_t i=0;
    for(;i<NumberOfSamples;i++)
        samples[i]=(i<(NumberOfSamples/2)?-127:128)+127;
}
void calculateSamplesSine(){
    uint16_t i=0;
    for(;i<NumberOfSamples;i++){
        samples[i]=(unsigned char)(sin(i*6.28/NumberOfSamples)*127+127);
    }
}
void calculateSamplesRamp(){
    uint16_t i=0;
    for(;i<NumberOfSamples;i++){
        samples[i]=i;
    }
}
void calculateSamplesTriangle(){
    uint16_t i=0;
    for(;i<NumberOfSamples;i++){
        samples[i]=i<128?i*2:(510-2*i);
    }
}


